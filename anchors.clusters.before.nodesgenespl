#!/usr/bin/perl
use warnings; use strict;
use Storable;


my $debug = 1;
my $strand_type = "";
my @strand;
if($strand_type eq "f"){
    @strand = (0,1,-1);
}elsif($strand_type eq "r") {
    @strand = (0,-1,1);
}else{
    @strand = (0,0,0);
}   
    
#\%inside, \%overhang, \%outside
#my $hrs = retrieve('anchors.dat');


my %n2r = %{retrieve('n2r.dat')}; #%{$$hrs[0]};
my %r2g = %{retrieve('r2g.dat')};#%{$$hrs[1]};
my %f2r = %{retrieve('f2r.dat')}; #%{$$hrs[2]};
my $node_bed = "/home/chuan/hdd1/Database/pangenome/nodes.len.bed.gz";
#################
foreach my $gene (sort keys %f2r){
	unless( exists $f2r{$gene} ){
		print "Gene $gene have encountered before.next...\n" if $debug;
		next;
	}
	
	my %seen;
	my %nodes_asso;
	my %genes_asso;

	print "\nFor checking $gene\n" if $debug;	

	## for each genes, extract all mapped reads , and then extract suspending nodes from these readsi
	## and collect them into %nodes_ini		
	print ">>>colecting suspending nodes for $gene\n" if $debug;
	my %nodes_ini = %{gene_nodes($gene,\%seen,\%genes_asso)};	## keep nodes expanded outside of gene
	
	print ">>>begin extending...\n" if $debug;
	while(1){
		my %nodes_cp = %nodes_ini;
		my @n_forloop = sort {$a <=> $b}  keys %nodes_ini;
		undef %nodes_ini ;

		unless(@n_forloop){
			print "\tno more nodes need to be tested\n" if $debug;
			last;
		}else{
			print "\tnodes used to extend @n_forloop\n" if $debug;
		}

		# loop through each node
		foreach my $n ( @n_forloop){
			my @reads_have_n;
			if($n2r{$n}){
				@reads_have_n = unique(@{$n2r{$n}});
				print "\tthese reads @reads_have_n overlapped with $n...\n" if $debug;
				delete $n2r{$n};
			}else{
				print "have seen node $n\n" if $debug;
				next;
			}
			# reads asscociate with this node
			foreach my $r (@reads_have_n){
				if($seen{R}{$r}){
					print "\thave seen  next ...  $r $n\n" if $debug;
					next;
				}
				print "\tMAIN: New read $r\n" if $debug;
				if(exists  $r2g{$r}{1} and exists  $r2g{$r}{2}){
					$seen{R}{$r} = 1;
					for my $w ( 1, 2){                                                 
						if($r2g{$r}{$w}{AN}){ # step into another annotation
							my @gs = keys %{$r2g{$r}{$w}{AN}};
							print "\tMAIN:$r $w overlapes with @gs\n" if $debug;
							foreach my $g (@gs){
								if($g eq "N"){
									my %sus_r = %{$r2g{$r}{$w}{NS}} ;
									my %nodes_r;
									my $rd = $strand[$w]; 
									foreach my $n (keys %sus_r){
										print "\t>$n\n" if $debug;
										my $nd = $sus_r{$n}[0];
										my($h,$t) = ($sus_r{$n}[2],$sus_r{$n}[3]);

										push @{$nodes_r{$n}{$rd*$nd}{H}}, $h;
										push @{$nodes_r{$n}{$rd*$nd}{T}}, $t;
										$nodes_r{$n}{L} = $sus_r{$n}[4];

									}
									print "\tMAIN:extract nodes from $g \n" if $debug;
									mergehash(\%nodes_ini , \%nodes_r );
								}else{
									print "\tMAIN:second expand gene $g\n" if $debug;
									my $node_g = gene_nodes($g,\%seen,\%genes_asso);
									mergehash(\%nodes_ini , $node_g);
								}
							}
						}
					}
				}else{
					$seen{R}{$r} = -1;
					print "\tNew read not paired. $r next\n";
					next;
				}
			}
		}
		mergehash(\%nodes_asso, \%nodes_cp);	
	}
	if($debug){
		print ">>> got nodes:\n";
		foreach my $n ( sort {$a <=> $b} keys %nodes_asso){
			foreach my $d (sort keys %{$nodes_asso{$n}} ) {
				print "\tN:$n\t$d\t$nodes_asso{$n}{$d}\n" ;
			}
		}
		foreach my $r ( sort keys %{$seen{R}} ){
			
			print "\tR:$r\t$seen{R}{$r}\n" ;
		}
		foreach my $g ( sort keys %genes_asso){
			print "\tG:$g\n" ;
		}
	}
}

sub node_genes{

}


sub gene_nodes{
	my($gene,$seen,$genes) = @_;
	my %nodes_g;
	my $debug_g  = 1;
	my %gs = ($gene,1);
	print "\n>>>> in sub-fucntion gene_nodes\n" if $debug_g;
	while(1){
		unless (%gs){
			last;
		}
		my @gs_for = keys %gs;
		undef %gs;
		print "\n\tGN:genes to test @gs_for\n" if $debug_g;

		foreach my $g ( @gs_for ){
			if($$seen{G}{$g}){
				print "\tGN:seen $g gene next\n" if $debug_g;
				next;
			}else{
				$$seen{G}{$g} = 1;
				$$genes{$g} = 1;
			}

			my $debug_g = 1;
			print "\t>>>GN:genes_nodes for $g\n" if $debug_g;
			
			my @rs_g = sort keys %{$f2r{$g}};
			delete $f2r{$g};
			
			my %nodes_r; ### nodes associated with genes
			foreach my $r ( @rs_g ){
				print "\t\tGN:checking $r\n" if $debug_g;
				if($$seen{R}{$r}){
					print "\t\tGN:seen $r next\n";
					next;
				}

				my $olen = 0;	
				if(exists $r2g{$r}{1} and exists $r2g{$r}{2}){
					$$seen{R}{$r} = 1;
					print "\t\tGN:Pair mapped \n" if $debug_g;
					foreach my $which ( 1,2){
						#### collect other genes associate with this read
						foreach my $og (keys %{$r2g{$r}{$which}{AN}}){
							if($og eq $g or $og eq "N"){
								next;
							}else{
								print "\t\t\tGN:NEW genes found.. $og\n";
								$gs{$og} = 1;
							}
						}
						### to finding suspending nodes for this specific read;
						my $rd = $strand[$which] ; # read direcition
						print "\t\tGN:ALN: $which " if $debug_g ;

						unless($r2g{$r}{$which}{NS}){
							print "\t\tGN:total inside feature $g $olen $r\n";
							next;
						}else{
							my %sus = %{$r2g{$r}{$which}{NS}} ;
							print "\t\tGN:have suspend region $g $olen $r \n";
							if($r2g{$r}{$which}{AN}{$g}){ ### overlap might be 0.
								$olen += $r2g{$r}{$which}{AN}{$g};
								delete $r2g{$r}{$which}{AN}{$g};
							}
							###########
							my @nodes = keys %sus;
							foreach my $n (@nodes){
								my $nd = $sus{$n}[0];	
								my($h,$t) = ($sus{$n}[2],$sus{$n}[3]);

								push @{$nodes_r{$n}{$rd*$nd}{H}}, $h;
								push @{$nodes_r{$n}{$rd*$nd}{T}}, $t;
								
								$nodes_r{$n}{L} = $sus{$n}[4];
							}
							print "\t\tGN:NODES: @nodes\n" if $debug_g;
						}
					}
				}else{
					$$seen{R}{$r} = -1;
					print "\t\tGN:No paired $r, skip this read ..\n" if $debug_g;
					next;
				}
				mergehash(\%nodes_g,\%nodes_r);		
				print "\t\tGN:Reads $r  saved\n" if $debug_g;
			}
			my @gn = keys %nodes_r;
			print "\t\t >>GN:gene==$gene @gn\n" if $debug_g;
		}
	}
	my @gn_all = keys %nodes_g;
	print "\tGN:gene_to_node finished\t@gn_all\n\n" if $debug_g;
	return \%nodes_g;
}


sub mergehash{
	my ($hr1,$hr2) = @_;
	foreach my $n (keys %$hr2){
		if(defined $$hr1{$n}){
			foreach my $d  ( keys %{$$hr2{$n}} ){
				if(defined $$hr1{$n}{$d}){
					push @{$$hr1{$n}{$d}{H}}, @{$$hr{$n}{$d}{H}};
					push @{$$hr1{$n}{$d}{T}}, @{$$hr{$n}{$d}{T}};
				}else{
					$$hr1{$n}{$d} = $$hr2{$n}{$d};
				}
			}
		}else{
			$$hr1{$n} = $$hr2{$n};
		}
	}
}

sub unique {
	my @input = @_;
	my %seen;
	my @unique = grep { !$seen{$_}++ } @input;
	return @unique;
}
